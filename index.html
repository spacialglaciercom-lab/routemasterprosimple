<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RouteMaster ONE | Waste Collection Router</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"/>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            --primary: #2563eb;
            --success: #10b981;
            --danger: #ef4444;
            --dark: #0f172a;
            --gray-100: #f1f5f9;
            --gray-200: #e2e8f0;
            --gray-300: #cbd5e1;
            --gray-600: #475569;
            --gray-700: #334155;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: var(--gray-100);
        }
        
        header {
            background: linear-gradient(135deg, var(--dark) 0%, #1e293b 100%);
            color: white;
            padding: 1rem 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.25rem;
            font-weight: 800;
        }
        
        .stats {
            background: white;
            padding: 1rem 1.5rem;
            display: flex;
            gap: 2rem;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .stat {
            display: flex;
            flex-direction: column;
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: var(--gray-600);
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--dark);
        }
        
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #map {
            flex: 1;
            background: var(--gray-200);
        }
        
        .controls {
            background: white;
            padding: 1rem 1.5rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            border-top: 1px solid var(--gray-200);
            box-shadow: 0 -2px 8px rgba(0,0,0,0.05);
        }
        
        .btn {
            padding: 0.625rem 1.25rem;
            border: 1px solid var(--gray-300);
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
        }
        
        .btn:hover:not(:disabled) {
            background: var(--gray-100);
            transform: translateY(-1px);
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .btn-success {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }
        
        .btn-danger {
            background: white;
            color: var(--danger);
            border-color: var(--danger);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input[type="file"] { display: none; }
        
        .spacer { flex: 1; }
        
        footer {
            background: var(--dark);
            color: var(--success);
            padding: 0.5rem 1.5rem;
            font-family: monospace;
            font-size: 0.8125rem;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .modal.active { display: flex; }
        
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 25px rgba(0,0,0,0.2);
        }
        
        .modal-header {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--dark);
        }
        
        .setting {
            margin-bottom: 1.5rem;
        }
        
        .setting-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--gray-700);
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--gray-100);
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--gray-300);
            border-radius: 6px;
            font-size: 0.875rem;
        }
        
        .toggle {
            position: relative;
            width: 48px;
            height: 24px;
        }
        
        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gray-300);
            border-radius: 24px;
            transition: 0.3s;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
        }
        
        input:checked + .toggle-slider {
            background: var(--primary);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
        
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--dark);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            display: none;
            z-index: 3000;
        }
        
        .toast.show { display: block; }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
        
        .loading.active { display: flex; }
        
        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--gray-200);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">üöõ RouteMaster <span style="color:#2563eb">ONE</span></div>
        <div style="font-size:0.75rem;opacity:0.7">v2.0</div>
    </header>
    
    <div class="stats">
        <div class="stat">
            <div class="stat-label">Waypoints</div>
            <div class="stat-value" id="stat-ways">0</div>
        </div>
        <div class="stat">
            <div class="stat-label">Nodes</div>
            <div class="stat-value" id="stat-nodes">0</div>
        </div>
        <div class="stat">
            <div class="stat-label">Route Length</div>
            <div class="stat-value"><span id="stat-dist">0.0</span> km</div>
        </div>
    </div>
    
    <div class="main">
        <div class="loading" id="loading">
            <div class="spinner"></div>
        </div>
        <div id="map"></div>
    </div>
    
    <div class="controls">
        <label class="btn">
            üìÅ Load OSM
            <input type="file" id="file-input" accept=".osm,.xml">
        </label>
        
        <button class="btn" id="btn-settings">‚öôÔ∏è Settings</button>
        
        <div class="spacer"></div>
        
        <button class="btn btn-success" id="btn-download" disabled>‚¨áÔ∏è Download GPX</button>
        <button class="btn btn-danger" id="btn-reset">üîÑ Reset</button>
    </div>
    
    <footer>
        <span id="status">Ready ‚Ä¢ Awaiting OSM Data</span>
    </footer>
    
    <div class="modal" id="modal-settings">
        <div class="modal-content">
            <div class="modal-header">Settings</div>
            
            <div class="setting">
                <div class="setting-row">
                    <label class="setting-label">Respect One-Ways</label>
                    <label class="toggle">
                        <input type="checkbox" id="set-oneway" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="setting">
                <label class="setting-label">Start Point (Optional)</label>
                <div style="display:flex;gap:0.5rem;margin-bottom:0.5rem">
                    <input type="number" id="start-lat" placeholder="Latitude" step="any">
                    <input type="number" id="start-lon" placeholder="Longitude" step="any">
                </div>
                <small style="color:var(--gray-600)">üí° Click map to get coordinates</small>
            </div>
            
            <button class="btn btn-primary" onclick="closeModal()" style="width:100%;margin-top:1rem">Close</button>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // State
        let map, nodes = new Map(), ways = [], circuit = [], layer = null, startMarker = null;
        let graph = null;
        
        // Graph data structure for Eulerian routing
        class Graph {
            constructor() {
                this.edges = new Map();
                this.degreeIn = new Map();
                this.degreeOut = new Map();
            }
            
            addEdge(from, to, dist, wayId, isDeadHead = false) {
                if (!this.edges.has(from)) {
                    this.edges.set(from, []);
                }
                
                this.edges.get(from).push({
                    to: to,
                    dist: dist,
                    wayId: wayId,
                    isDeadHead: isDeadHead,
                    used: false
                });
                
                this.degreeOut.set(from, (this.degreeOut.get(from) || 0) + 1);
                this.degreeIn.set(to, (this.degreeIn.get(to) || 0) + 1);
            }
            
            getUnbalanced() {
                const sources = [];
                const sinks = [];
                
                const allNodes = new Set([...this.degreeOut.keys(), ...this.degreeIn.keys()]);
                
                for (const node of allNodes) {
                    const outDeg = this.degreeOut.get(node) || 0;
                    const inDeg = this.degreeIn.get(node) || 0;
                    const diff = outDeg - inDeg;
                    
                    if (diff > 0) {
                        for (let i = 0; i < diff; i++) sinks.push(node);
                    } else if (diff < 0) {
                        for (let i = 0; i < -diff; i++) sources.push(node);
                    }
                }
                
                return { sources, sinks };
            }
            
            reset() {
                for (const edgeList of this.edges.values()) {
                    for (const edge of edgeList) {
                        edge.used = false;
                    }
                }
            }
        }
        
        // Haversine distance
        function haversine(coord1, coord2) {
            const R = 6371e3;
            const toRad = Math.PI / 180;
            const lat1 = coord1[0] * toRad;
            const lat2 = coord2[0] * toRad;
            const deltaLat = (coord2[0] - coord1[0]) * toRad;
            const deltaLon = (coord2[1] - coord1[1]) * toRad;
            
            const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                      Math.cos(lat1) * Math.cos(lat2) *
                      Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
            
            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
        
        // Dijkstra's shortest path
        function dijkstra(graph, start, maxDist) {
            const dist = new Map();
            const prev = new Map();
            const visited = new Set();
            const queue = [{node: start, dist: 0}];
            
            dist.set(start, 0);
            
            while (queue.length > 0) {
                queue.sort((a, b) => a.dist - b.dist);
                const current = queue.shift();
                
                if (visited.has(current.node)) continue;
                if (current.dist > maxDist) continue;
                
                visited.add(current.node);
                
                const edges = graph.edges.get(current.node);
                if (!edges) continue;
                
                for (const edge of edges) {
                    if (edge.isDeadHead) continue;
                    
                    const newDist = current.dist + edge.dist;
                    
                    if (newDist < (dist.get(edge.to) || Infinity)) {
                        dist.set(edge.to, newDist);
                        prev.set(edge.to, current.node);
                        queue.push({node: edge.to, dist: newDist});
                    }
                }
            }
            
            return { dist, prev };
        }
        
        // Balance graph with dead-head edges
        function balanceGraph(maxDeadHead) {
            const { sources, sinks } = graph.getUnbalanced();
            
            if (sources.length === 0) return;
            
            const used = new Set();
            
            for (const source of sources) {
                const { dist, prev } = dijkstra(graph, source, maxDeadHead);
                
                let bestSink = null;
                let bestDist = Infinity;
                
                for (const sink of sinks) {
                    if (used.has(sink)) continue;
                    
                    const d = dist.get(sink);
                    if (d !== undefined && d < bestDist && d <= maxDeadHead) {
                        bestDist = d;
                        bestSink = sink;
                    }
                }
                
                if (bestSink) {
                    // Reconstruct path
                    const path = [];
                    let current = bestSink;
                    while (current !== source) {
                        path.unshift(current);
                        current = prev.get(current);
                        if (!current) break;
                    }
                    path.unshift(source);
                    
                    // Add dead-head edges along path
                    for (let i = 0; i < path.length - 1; i++) {
                        const from = path[i];
                        const to = path[i + 1];
                        const c1 = nodes.get(from);
                        const c2 = nodes.get(to);
                        if (c1 && c2) {
                            graph.addEdge(from, to, haversine(c1, c2), 'deadhead', true);
                        }
                    }
                    
                    used.add(bestSink);
                }
            }
        }
        
        // Find Eulerian circuit using Hierholzer's algorithm
        function findEulerianCircuit(startNode) {
            graph.reset();
            
            const stack = [startNode];
            const path = [];
            
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const edges = graph.edges.get(current);
                
                let foundUnused = false;
                if (edges) {
                    for (const edge of edges) {
                        if (!edge.used) {
                            edge.used = true;
                            stack.push(edge.to);
                            foundUnused = true;
                            break;
                        }
                    }
                }
                
                if (!foundUnused) {
                    path.push(stack.pop());
                }
            }
            
            return path.reverse();
        }
        
        // Initialize
        window.onload = function() {
            if (typeof L === 'undefined') {
                status('ERROR: Map library failed to load');
                return;
            }
            
            map = L.map('map').setView([51.5, -0.1], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap'
            }).addTo(map);
            
            map.on('click', function(e) {
                const lat = e.latlng.lat.toFixed(6);
                const lon = e.latlng.lng.toFixed(6);
                L.popup()
                    .setLatLng(e.latlng)
                    .setContent('<div style="padding:0.5rem"><b>Coordinates</b><br>Lat: ' + lat + '<br>Lon: ' + lon + '<br><button onclick="useCoords(' + lat + ',' + lon + ')" style="margin-top:0.5rem;padding:0.5rem;background:#2563eb;color:white;border:none;border-radius:4px;cursor:pointer;width:100%">Use as Start</button></div>')
                    .openOn(map);
            });
            
            setupEvents();
            status('Ready');
        };
        
        window.useCoords = function(lat, lon) {
            document.getElementById('start-lat').value = lat;
            document.getElementById('start-lon').value = lon;
            map.closePopup();
            toast('‚úì Start point set');
        };
        
        function setupEvents() {
            document.getElementById('file-input').onchange = function(e) {
                if (e.target.files[0]) loadFile(e.target.files[0]);
            };
            
            document.getElementById('btn-settings').onclick = function() {
                document.getElementById('modal-settings').classList.add('active');
            };
            
            document.getElementById('btn-download').onclick = downloadGPX;
            
            document.getElementById('btn-reset').onclick = function() {
                if (layer) map.removeLayer(layer);
                if (startMarker) map.removeLayer(startMarker);
                nodes.clear();
                ways = [];
                circuit = [];
                document.getElementById('stat-ways').textContent = '0';
                document.getElementById('stat-nodes').textContent = '0';
                document.getElementById('stat-dist').textContent = '0.0';
                document.getElementById('btn-download').disabled = true;
                document.getElementById('file-input').value = '';
                toast('‚úì Reset complete');
            };
        }
        
        function loadFile(file) {
            loading(true);
            status('Loading OSM file...');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    parseOSM(e.target.result);
                } catch(err) {
                    toast('‚úó Error: ' + err.message);
                    status('Error loading file');
                    loading(false);
                }
            };
            reader.onerror = function() {
                toast('‚úó Failed to read file');
                loading(false);
            };
            reader.readAsText(file);
        }
        
        function parseOSM(xml) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            
            if (doc.querySelector('parsererror')) {
                throw new Error('Invalid XML format');
            }
            
            nodes.clear();
            ways = [];
            
            // Parse nodes
            doc.querySelectorAll('node').forEach(function(n) {
                const id = n.getAttribute('id');
                const lat = parseFloat(n.getAttribute('lat'));
                const lon = parseFloat(n.getAttribute('lon'));
                if (id && !isNaN(lat) && !isNaN(lon)) {
                    nodes.set(id, [lat, lon]);
                }
            });
            
            // Parse ways
            const allowed = ['residential', 'tertiary', 'secondary', 'primary', 'unclassified', 'service', 'living_street'];
            const excluded = ['motorway', 'motorway_link', 'trunk', 'trunk_link'];
            
            doc.querySelectorAll('way').forEach(function(w) {
                const tags = {};
                w.querySelectorAll('tag').forEach(function(t) {
                    tags[t.getAttribute('k')] = t.getAttribute('v');
                });
                
                if (!tags.highway || excluded.includes(tags.highway) || !allowed.includes(tags.highway)) {
                    return;
                }
                
                const nodeIds = [];
                w.querySelectorAll('nd').forEach(function(nd) {
                    nodeIds.push(nd.getAttribute('ref'));
                });
                
                if (nodeIds.length >= 2) {
                    ways.push({
                        id: w.getAttribute('id'),
                        nodes: nodeIds,
                        oneway: tags.oneway === 'yes'
                    });
                }
            });
            
            if (ways.length === 0) {
                throw new Error('No valid roads found');
            }
            
            toast('‚úì Loaded ' + ways.length + ' roads');
            buildRoute();
        }
        
        function buildRoute() {
            status('Building graph...');
            
            const respectOneways = document.getElementById('set-oneway').checked;
            
            // Build graph
            graph = new Graph();
            
            for (const way of ways) {
                for (let i = 0; i < way.nodes.length - 1; i++) {
                    const from = way.nodes[i];
                    const to = way.nodes[i + 1];
                    
                    const c1 = nodes.get(from);
                    const c2 = nodes.get(to);
                    
                    if (!c1 || !c2) continue;
                    
                    const dist = haversine(c1, c2);
                    
                    graph.addEdge(from, to, dist, way.id, false);
                    
                    if (!way.oneway || !respectOneways) {
                        graph.addEdge(to, from, dist, way.id, false);
                    }
                }
            }
            
            status('Balancing graph...');
            
            // Balance graph with dead-heading
            const maxDeadHead = 100; // 100 meters
            balanceGraph(maxDeadHead);
            
            status('Finding optimal circuit...');
            
            // Find start node
            let startNode = null;
            const startLat = parseFloat(document.getElementById('start-lat').value);
            const startLon = parseFloat(document.getElementById('start-lon').value);
            
            if (!isNaN(startLat) && !isNaN(startLon)) {
                // Find nearest node to custom start
                let minDist = Infinity;
                for (const [id, coord] of nodes.entries()) {
                    const d = haversine([startLat, startLon], coord);
                    if (d < minDist && d < 500) {
                        minDist = d;
                        startNode = id;
                    }
                }
                
                if (startNode && startMarker) {
                    map.removeLayer(startMarker);
                }
                if (startNode) {
                    startMarker = L.marker([startLat, startLon], {
                        icon: L.divIcon({
                            html: '<div style="background:#10b981;width:20px;height:20px;border-radius:50%;border:3px solid white;box-shadow:0 2px 4px rgba(0,0,0,0.3)"></div>',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    }).addTo(map);
                }
            }
            
            if (!startNode) {
                startNode = graph.edges.keys().next().value;
            }
            
            // Find Eulerian circuit
            circuit = findEulerianCircuit(startNode);
            
            // Calculate stats
            let totalDist = 0;
            let deadHeadDist = 0;
            
            for (const edgeList of graph.edges.values()) {
                for (const edge of edgeList) {
                    if (edge.isDeadHead) {
                        deadHeadDist += edge.dist;
                    } else {
                        totalDist += edge.dist;
                    }
                }
            }
            
            // Update stats
            document.getElementById('stat-ways').textContent = ways.length;
            document.getElementById('stat-nodes').textContent = nodes.size;
            document.getElementById('stat-dist').textContent = (totalDist / 1000).toFixed(2);
            
            // Render on map
            if (layer) map.removeLayer(layer);
            
            const coords = [];
            for (let i = 0; i < circuit.length; i++) {
                const coord = nodes.get(circuit[i]);
                if (coord) coords.push(coord);
            }
            
            if (coords.length > 1) {
                layer = L.polyline(coords, {
                    color: '#2563eb',
                    weight: 4,
                    opacity: 0.8
                }).addTo(map);
                
                map.fitBounds(layer.getBounds(), {padding: [50, 50]});
            }
            
            document.getElementById('btn-download').disabled = false;
            status('Ready ‚Ä¢ Optimized route with ' + circuit.length + ' waypoints');
            loading(false);
            toast('‚úì Route optimized with Eulerian circuit');
        }
        
        function downloadGPX() {
            if (circuit.length === 0) {
                toast('‚ö† No route to export');
                return;
            }
            
            try {
                let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
                gpx += '<gpx version="1.1" creator="RouteMaster ONE">\n';
                gpx += '<trk><n>Route</n><trkseg>\n';
                
                for (let i = 0; i < circuit.length; i++) {
                    const coord = nodes.get(circuit[i]);
                    if (coord) {
                        gpx += '<trkpt lat="' + coord[0] + '" lon="' + coord[1] + '"></trkpt>\n';
                    }
                }
                
                gpx += '</trkseg></trk>\n</gpx>';
                
                // Create download
                const blob = new Blob([gpx], {type: 'application/gpx+xml'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'route_' + Date.now() + '.gpx';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                toast('‚úì GPX downloaded');
                status('GPX exported');
            } catch(err) {
                toast('‚úó Download failed: ' + err.message);
            }
        }
        
        function closeModal() {
            document.getElementById('modal-settings').classList.remove('active');
        }
        
        function loading(show) {
            document.getElementById('loading').classList.toggle('active', show);
        }
        
        function toast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(function() {
                t.classList.remove('show');
            }, 3000);
        }
        
        function status(msg) {
            document.getElementById('status').textContent = msg;
        }
    </script>
</body>
</html>
