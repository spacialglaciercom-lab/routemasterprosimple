<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RouteMaster PRO - OSM Route Generator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #map { height: 100vh; width: 100%; z-index: 1; }
        .dragover { background-color: #e0f2fe !important; border: 2px dashed #0284c7 !important; }
        #overlay-loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center; flex-direction: column; color: white; }
        #overlay-initial { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 999; display: flex; align-items: center; justify-content: center; }
        .hidden { display: none !important; }
        #floating-actions { position: fixed; bottom: 20px; right: 20px; z-index: 100; }
        .coord-input:focus { ring-width: 2px; ring-color: #2563eb; border-color: #2563eb; }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div id="overlay-initial">
        <div class="text-center p-8 bg-white rounded-lg shadow-xl max-w-md w-full mx-4">
            <h1 class="text-3xl font-bold mb-4">RouteMaster PRO</h1>
            <p class="mb-6 text-gray-600">Upload an OSM XML file to generate an optimized route</p>
            
            <div class="mb-6 bg-slate-50 p-4 rounded-lg border border-slate-200 text-left">
                <label class="block text-sm font-bold text-gray-700 mb-2">üìç Starting Point Coordinates (Optional)</label>
                <div class="flex gap-3">
                    <div class="w-1/2">
                        <input type="number" id="startLat" step="any" placeholder="Latitude (e.g. 45.32)" 
                               class="w-full p-2 border border-gray-300 rounded text-sm focus:outline-none">
                    </div>
                    <div class="w-1/2">
                        <input type="number" id="startLon" step="any" placeholder="Longitude (e.g. -74.18)" 
                               class="w-full p-2 border border-gray-300 rounded text-sm focus:outline-none">
                    </div>
                </div>
            </div>

            <div id="dropZone" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center transition group hover:border-blue-500">
                <p class="text-lg mb-2 text-gray-700 pointer-events-none">üìÇ Drag & Drop OSM File Here</p>
                <p class="text-sm text-gray-500 mb-4 pointer-events-none">or</p>
                
                <input type="file" id="fileInput" accept=".osm,.xml" style="display:none">
                
                <button type="button" 
                        onclick="document.getElementById('fileInput').click()" 
                        class="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition shadow-md font-medium">
                    Select File
                </button>
            </div>
        </div>
    </div>
    
    <div id="overlay-loading" class="hidden">
        <h2 id="loading-title" class="text-2xl font-bold mb-2">Processing...</h2>
        <p id="loading-subtitle" class="text-lg">Please wait</p>
    </div>
    
    <div id="floating-actions" class="hidden">
        <div class="bg-white rounded-lg shadow-lg p-4 mb-4">
            <div class="flex items-center gap-4 mb-4">
                <div>
                    <span id="status-dot" class="relative inline-flex rounded-full h-3 w-3 bg-slate-400"></span>
                    <span id="status-text" class="text-[10px] font-bold text-slate-600 uppercase ml-2">Idle</span>
                </div>
                <div class="text-sm">
                    <span id="stat-ways">0 Ways</span> | <span id="stat-dist">0.00 km</span>
                </div>
            </div>
            <div class="flex gap-2">
                <button onclick="downloadGPX()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm font-medium transition">Download GPX</button>
                <button onclick="resetApp()" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 text-sm font-medium transition">Reset</button>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let map = null;
        let routeLayer = null;
        let osmData = null;
        let routePath = null;

        // Show loading overlay
        function showLoading(title = 'Processing...', subtitle = 'Please wait') {
            document.getElementById('overlay-loading').classList.remove('hidden');
            document.getElementById('loading-title').textContent = title;
            document.getElementById('loading-subtitle').textContent = subtitle;
        }

        // Hide loading overlay
        function hideLoading() {
            document.getElementById('overlay-loading').classList.add('hidden');
        }

        // Update status
        function updateStatus(status, color) {
            document.getElementById('status-dot').className = `relative inline-flex rounded-full h-3 w-3 bg-${color}-500`;
            document.getElementById('status-text').textContent = status;
        }

        // Update stats
        function updateStats(ways, distance) {
            document.getElementById('stat-ways').textContent = `${ways} Ways`;
            document.getElementById('stat-dist').textContent = `${distance.toFixed(2)} km`;
        }

        // Parse OSM XML and extract ways
        function parseOSM(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            
            const ways = [];
            const wayElements = xmlDoc.getElementsByTagName('way');
            
            for (let way of wayElements) {
                const tags = {};
                const tagElements = way.getElementsByTagName('tag');
                for (let tag of tagElements) {
                    tags[tag.getAttribute('k')] = tag.getAttribute('v');
                }
                
                // Only include highways (roads, paths, etc.)
                if (tags.highway) {
                    const nds = [];
                    const ndElements = way.getElementsByTagName('nd');
                    for (let nd of ndElements) {
                        nds.push(nd.getAttribute('ref'));
                    }
                    
                    if (nds.length > 0) {
                        ways.push({ id: way.getAttribute('id'), nodes: nds, tags });
                    }
                }
            }
            
            return ways;
        }

        // Get node coordinates from OSM XML
        function getNodes(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            
            const nodes = {};
            const nodeElements = xmlDoc.getElementsByTagName('node');
            
            for (let node of nodeElements) {
                nodes[node.getAttribute('id')] = {
                    lat: parseFloat(node.getAttribute('lat')),
                    lon: parseFloat(node.getAttribute('lon'))
                };
            }
            
            return nodes;
        }

        // Generate route from ways and nodes
        function generateRoute(ways, nodes) {
            const routePoints = [];
            
            for (let way of ways) {
                const wayPoints = [];
                for (let nodeId of way.nodes) {
                    if (nodes[nodeId]) {
                        wayPoints.push([nodes[nodeId].lat, nodes[nodeId].lon]);
                    }
                }
                if (wayPoints.length > 0) {
                    routePoints.push(...wayPoints);
                }
            }
            
            // Simple optimization: remove consecutive duplicates
            const optimized = routePoints.filter((point, index) => {
                if (index === 0) return true;
                const prev = routePoints[index - 1];
                return !(point[0] === prev[0] && point[1] === prev[1]);
            });
            
            return optimized;
        }

        // Calculate distance
        function calculateDistance(points) {
            if (points.length < 2) return 0;
            
            let total = 0;
            for (let i = 1; i < points.length; i++) {
                const lat1 = points[i-1][0], lon1 = points[i-1][1];
                const lat2 = points[i][0], lon2 = points[i][1];
                
                // Haversine formula (km)
                const R = 6371;
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                total += R * c;
            }
            return total;
        }

        // Process file upload
        function handleFileUpload(files) {
            if (!files || files.length === 0) return;
            
            const file = files[0];
            showLoading('Loading OSM file...', 'Parsing data');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    updateStatus('Parsing', 'yellow');
                    const xmlText = e.target.result;
                    
                    // Parse OSM data
                    const ways = parseOSM(xmlText);
                    const nodes = getNodes(xmlText);
                    const routePoints = generateRoute(ways, nodes);
                    
                    if (routePoints.length === 0) {
                        throw new Error('No valid route data found in the file');
                    }
                    
                    // Hide initial overlay
                    document.getElementById('overlay-initial').classList.add('hidden');
                    
                    // Initialize map if needed
                    if (!map) {
                        map = L.map('map');
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '¬© OpenStreetMap contributors'
                        }).addTo(map);
                    }
                    
                    // Clear existing route
                    if (routeLayer) {
                        map.removeLayer(routeLayer);
                    }
                    
                    // Add route to map
                    routeLayer = L.polyline(routePoints, {
                        color: '#2563eb',
                        weight: 4,
                        opacity: 0.8
                    }).addTo(map);
                    
                    // Fit map to route
                    map.fitBounds(routeLayer.getBounds().pad(0.1));
                    
                    // Store data for GPX export
                    routePath = routePoints;
                    
                    // Update UI
                    updateStatus('Ready', 'green');
                    updateStats(ways.length, calculateDistance(routePoints));
                    document.getElementById('floating-actions').classList.remove('hidden');
                    
                } catch (error) {
                    alert('Error processing file: ' + error.message);
                    console.error(error);
                    updateStatus('Error', 'red');
                } finally {
                    hideLoading();
                }
            };
            
            reader.readAsText(file);
        }

        // Download GPX
        function downloadGPX() {
            if (!routePath || routePath.length === 0) {
                alert('No route to download');
                return;
            }
            
            let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="RouteMaster PRO">\n<trk>\n<trkseg>\n';
            
            for (let point of routePath) {
                gpx += `<trkpt lat="${point[0]}" lon="${point[1]}"></trkpt>\n`;
            }
            
            gpx += '</trkseg>\n</trk>\n</gpx>';
            
            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'route.osm.gpx';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Reset app
        function resetApp() {
            if (routeLayer) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
            document.getElementById('floating-actions').classList.add('hidden');
            document.getElementById('overlay-initial').classList.remove('hidden');
            routePath = null;
            osmData = null;
        }

        // DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const startLat = document.getElementById('startLat');
            const startLon = document.getElementById('startLon');

            // File input change handler
            fileInput.addEventListener('change', (e) => {
                handleFileUpload(e.target.files);
            });

            // Optional: Use provided start coordinates if available
            fileInput.addEventListener('change', (e) => {
                if (startLat.value && startLon.value) {
                    console.log('Start coordinates provided:', startLat.value, startLon.value);
                }
            });

            // Drag & drop handlers
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);
            });

            dropZone.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files);
                }
            }, false);
        });
    </script>
</body>
</html>


